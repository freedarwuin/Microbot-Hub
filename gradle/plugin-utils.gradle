// gradle/plugin-utils.gradle
// Common utilities and functions for plugin processing

import java.security.MessageDigest

ext {
    // Common plugin discovery and validation
    discoverPlugins = { pluginsDir ->
        def pluginDirs = pluginsDir.listFiles()?.findAll { it.isDirectory() } ?: []
        def validPlugins = []

        pluginDirs.each { pluginDir ->
            def pluginJavaFile = pluginDir.listFiles()?.find { file ->
                file.name.endsWith("Plugin.java")
            }

            if (pluginJavaFile) {
                validPlugins << [
                    dir: pluginDir,
                    javaFile: pluginJavaFile,
                    name: pluginJavaFile.name - '.java',
                    sourceSetName: pluginDir.name
                ]
            } else {
                logger.warn("⚠️ No Plugin.java file found in ${pluginDir.name}")
            }
        }

        return validPlugins
    }

    // Common source set configuration
    configurePluginSourceSet = { plugin ->
        sourceSets {
            "${plugin.sourceSetName}" {
                java {
                    srcDirs = ["src/main/java"]
                    include "${project.ext.getPluginsIncludePath()}/PluginConstants.java"
                    include "${project.ext.getPluginsIncludePath()}/${plugin.dir.name}/**"
                }
                resources {
                    srcDirs = ["src/main/resources"]
                    include "${project.ext.getPluginsIncludePath()}/${plugin.dir.name}/**"
                    exclude "**/docs/**"
                }
                compileClasspath += configurations.microbotRuntime
                runtimeClasspath += configurations.microbotRuntime
            }
        }
    }

    // Common dependency configuration
    configurePluginDependencies = { plugin ->
        def pluginConfigName = "${plugin.name}ShadowDeps"
        configurations.create(pluginConfigName) {
            extendsFrom configurations.pluginShadowClasspath
        }

        def depsFile = new File(project.rootDir,
            "${project.ext.getPluginsResourcePath()}/${plugin.dir.name}/dependencies.txt")

        logger.info("📁 Checking dependencies for ${plugin.name}")

        if (depsFile.exists()) {
            logger.info("   File size: ${depsFile.length()} bytes")
            def lines = depsFile.readLines()
            logger.info("   Lines found: ${lines.size()}")

            lines.each { dep ->
                if (dep.trim()) {
                    logger.info("Adding dependency: ${dep.trim()}")
                    dependencies.add(pluginConfigName, dep.trim())
                }
            }
        }

        return pluginConfigName
    }

    // Common JAR exclusions
    getCommonJarExclusions = {
        return [
                'module-info.class',
                'META-INF/versions/**',
                'META-INF/INDEX.LIST',
                'META-INF/*.SF',
                'META-INF/*.DSA',
                'META-INF/*.RSA',
                'META-INF/DEPENDENCIES',
                'META-INF/LICENSE*',
                'META-INF/NOTICE*',
                'META-INF/MANIFEST.MF',
                'META-INF/native-image/**',
                'META-INF/services/java.**',
                'META-INF/services/javax.**',
                'META-INF/services/sun.**',
                'META-INF/services/com.sun.**',
                '**/.gitkeep',
                '**/.DS_Store',
                '**/Thumbs.db',
                '**/module-info.class',
                '**/plugins.json',
                '**/docs/**',
                '**/dependencies.txt',
        ]
    }

    // SHA256 computation utility
    computeSHA256 = { File file ->
        if (!file.exists()) {
            logger.warn("⚠️ JAR file not found: ${file.absolutePath}")
            return "FILE_NOT_FOUND"
        }

        MessageDigest digest = MessageDigest.getInstance("SHA-256")
        file.withInputStream { inputStream ->
            byte[] buffer = new byte[8192]
            int bytesRead
            while ((bytesRead = inputStream.read(buffer)) != -1) {
                digest.update(buffer, 0, bytesRead)
            }
        }

        byte[] hash = digest.digest()
        StringBuilder hexString = new StringBuilder()
        for (byte b : hash) {
            String hex = Integer.toHexString(0xff & b)
            if (hex.length() == 1) {
                hexString.append('0')
            }
            hexString.append(hex)
        }
        return hexString.toString()
    }

    // Plugin descriptor parsing utility
    getPluginDescriptorInfo = { File javaFile ->
        def content = javaFile.getText('UTF-8')
        def descriptor = [:]

        def nameMatcher = content =~ /name\s*=\s*(?:[\w$.]+\s*\+\s*)?"([^"]+)"/
        def descMatcher     = content =~ /description\s*=\s*"([^"]+)"/
        def tagsMatcher     = content =~ /tags\s*=\s*\{([^}]+)\}/
        def authorsMatcher   = content =~ /authors\s*=\s*\{\s*((?:"[^"]*"\s*,?\s*)+)\}/
        def singleAuthorMatcher = content =~ /authors\s*=\s*"([^"]+)"/
        def iconUrlMatcher  = content =~ /iconUrl\s*=\s*"([^"]+)"/
        def cardUrlMatcher  = content =~ /cardUrl\s*=\s*"([^"]+)"/
        def versionMatcher  = content =~ /version\s*=\s*"([^"]+)"/
        def minClientVersionMatcher  = content =~ /minClientVersion\s*=\s*"([^"]+)"/
        def disableMatcher  = content =~ /disable\s*=\s*(true|false)/

        // Required fields - throw exceptions if missing
        if (!nameMatcher.find()) {
            throw new GradleException("Missing required 'name' field in plugin descriptor: ${javaFile.absolutePath}")
        }
        descriptor.name = nameMatcher.group(1)

        if (!minClientVersionMatcher.find()) {
            throw new GradleException("Missing required 'minClientVersion' field in plugin descriptor: ${javaFile.absolutePath}")
        }
        descriptor.minClientVersion = minClientVersionMatcher.group(1)

        // Optional fields
        if (authorsMatcher.find()) {
            descriptor.authors = authorsMatcher.group(1).split(',').collect { it.trim().replaceAll('"','') }
        } else if (singleAuthorMatcher.find()) {
            descriptor.authors = [singleAuthorMatcher.group(1)]
        } else {
            descriptor.authors = project.ext.DEFAULT_AUTHORS
        }
        descriptor.description = descMatcher.find() ? descMatcher.group(1) : ''
        descriptor.iconUrl = iconUrlMatcher.find() ? iconUrlMatcher.group(1) : ''
        descriptor.cardUrl = cardUrlMatcher.find() ? cardUrlMatcher.group(1) : ''
        descriptor.version = versionMatcher.find() ? versionMatcher.group(1) : project.ext.DEFAULT_VERSION
        descriptor.disable = disableMatcher.find() ? Boolean.parseBoolean(disableMatcher.group(1)) : false

        descriptor.tags = tagsMatcher.find() ?
                tagsMatcher.group(1).split(',').collect { it.trim().replaceAll('"','') } :
                []

        descriptor
    }

    // Generate plugins JSON data
    generatePluginsJsonData = { allPlugins, jarOutputDir ->
        def plugins = []

        allPlugins.each { plugin ->
            try {
                def descriptorInfo = getPluginDescriptorInfo(plugin.javaFile)

                logger.info("Parsing ${plugin.name} - (${descriptorInfo.name})")

                def parsed = [:]
                parsed.internalName = plugin.name
                parsed.name = descriptorInfo.name
                parsed.description = descriptorInfo.description
                parsed.tags = descriptorInfo.tags
                parsed.version = descriptorInfo.version
                parsed.minClientVersion = descriptorInfo.minClientVersion
                parsed.authors = descriptorInfo.authors
                parsed.iconUrl = descriptorInfo.iconUrl
                parsed.cardUrl = descriptorInfo.cardUrl
                parsed.disable = descriptorInfo.disable

                // Add SHA256
                def jarFile = new File(jarOutputDir, "${plugin.name}-${descriptorInfo.version}.jar")
                parsed.sha256 = computeSHA256(jarFile)

                // Add Nexus URL using centralized config
                def nexusBase = project.ext.getNexusPluginsUrl()
                if (nexusBase.endsWith('/')) {
                    nexusBase = nexusBase.substring(0, nexusBase.length() - 1)
                }
                def pluginId = plugin.name.toLowerCase()
                parsed.url = "${nexusBase}/${project.ext.MAVEN_GROUP_ID.replace('.', '/')}/${pluginId}/${descriptorInfo.version}/${pluginId}-${descriptorInfo.version}.jar"

                plugins << parsed
                logger.info("✅ Plugin ${plugin.name} processed successfully")

            } catch (Exception e) {
                logger.warn("⚠️ Error processing ${plugin.name}: ${e.message}")
            }
        }

        return plugins
    }

    // Create shadow JAR task for plugin - returns task configuration closure
    getPluginJarTaskConfig = { plugin, pluginConfigName ->
        return {
            from(sourceSets.main.output) {
                // Get the relative path of the plugin directory within the source tree
                def pluginRelativePath = sourceSets.main.java.srcDirs.find { srcDir ->
                    plugin.dir.absolutePath.startsWith(srcDir.absolutePath)
                }

                if (pluginRelativePath) {
                    def relativePath = pluginRelativePath.toPath().relativize(plugin.dir.toPath()).toString().replace('\\', '/')
                    include "${relativePath}/**"
                    println "Including classes from path: ${relativePath}/**"
                } else {
                    // Fallback: include by plugin name pattern if directory structure doesn't match
                    include "**/${pluginName}/**"
                    include "**/${pluginName}.class"
                    include "**/${pluginName}Plugin.class"
                    println "Using fallback include pattern for plugin: ${pluginName}"
                }
            }


            dependsOn tasks.named("compile${plugin.sourceSetName.capitalize()}Java")

            def version = pluginVersionFromPluginJson(plugin.dir)
            archiveFileName.set("${plugin.name}-${version}.jar")
            archiveBaseName.set(plugin.name)
            archiveVersion.set(version)
            archiveClassifier.set('')
            configurations = [project.configurations.getByName(pluginConfigName)]
            destinationDirectory.set(layout.buildDirectory.dir("libs"))

            duplicatesStrategy = DuplicatesStrategy.EXCLUDE
            entryCompression = ZipEntryCompression.DEFLATED
            filteringCharset = 'UTF-8'

            // Centralized reproducible build settings
            preserveFileTimestamps = false
            reproducibleFileOrder = true

            // Override manifest attributes
            manifest {
                attributes(
                        'Implementation-Title': plugin.name,
                        'Implementation-Version': version,
                        'Built-By': 'microbot-build',
                        'Created-By': 'Gradle Shadow Plugin'
                )

                attributes.remove('Build-Jdk-Spec')
                attributes.remove('Built-Jdk')
                attributes.remove('Build-Jdk')
                attributes.remove('Build-Date')
                attributes.remove('Build-Time')
            }

            eachFile { fileCopyDetails ->
                fileCopyDetails.mode = 0644 // rw-r--r--
            }

            getCommonJarExclusions().each { pattern ->
                exclude pattern
            }

            outputs.upToDateWhen { false }
        }
    }

    // Documentation processing utilities
    copyPluginDocumentation = { plugin, publicDir ->
        def pluginName = plugin.name
        def pluginDirName = plugin.dir.name

        def docsDir = new File("${project.ext.getPluginsResourcePath()}/${pluginDirName}/docs")
        def assetsSourceDir = new File(docsDir, "assets")

        if (!docsDir.exists() || !docsDir.isDirectory()) {
            logger.warn("⚠️ No docs folder found at: ${docsDir.absolutePath}")
            return false
        }

        def readmeFile = docsDir.listFiles()?.find { file ->
            file.name.toLowerCase() == "readme.md"
        }

        def pluginDocsDir = new File(publicDir, pluginName)
        pluginDocsDir.mkdirs()

        if (readmeFile?.exists()) {
            project.copy {
                from readmeFile
                into pluginDocsDir
            }
            logger.info("✅ Copied ${readmeFile.name} for plugin: ${pluginName}")
        } else {
            logger.warn("⚠️ No README.md found in docs folder for plugin: ${pluginName}")
        }

        if (assetsSourceDir.exists() && assetsSourceDir.isDirectory()) {
            def assetsDestDir = new File(pluginDocsDir, "assets")
            project.copy {
                from assetsSourceDir
                into assetsDestDir
            }
            logger.info("✅ Copied assets for plugin: ${pluginName}")
        } else {
            logger.info("ℹ️ No assets folder found for plugin: ${pluginName}")
        }

        return true
    }
}
